import json
import time

import disnake
import pomice
import requests
from disnake import SelectOption
from disnake.ext import commands
from disnake.ext.commands import Paginator

from helpers.dump import Dump as Build
from objects.exceptions import *
from validators.player import check_player_btn_decorator

build = Build()

errors = json.load(open("data/resources/errors.json", "r", encoding="utf-8"))

filters = {
    "ChannelMix": pomice.ChannelMix(tag="mix"),
    "Distortion": pomice.Distortion(tag="dist"),
    "Karaoke": pomice.Karaoke(tag="kar"),
    "LowPass": pomice.LowPass(tag="low"),
    "Rotation": pomice.Rotation(tag="rot", rotation_hertz=1),
    "Tremolo": pomice.Tremolo(tag="trem"),
    "Vibrato": pomice.Vibrato(tag="vibr"),
    "Boost": pomice.Equalizer.boost(),
    "Metal": pomice.Equalizer.metal(),
    "Piano": pomice.Equalizer.piano(),
    "VaporWave": pomice.Timescale.vaporwave(),
    "Nightcore": pomice.Timescale.nightcore(),
}

descriptions = [
    "–ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–≤—É–∫–∞",
    "–∏—Å–∫–∞–∂–µ–Ω–∏–µ",
    "—É–±—Ä–∞—Ç—å –≥–æ–ª–æ—Å",
    "–ø–æ–¥–∞–≤–ª–µ–Ω–∏–µ –≤—ã—Å–æ–∫–∏—Ö —á–∞—Å—Ç–æ—Ç",
    "–≤—Ä–∞—â–µ–Ω–∏–µ",
    "–∫–æ–ª–µ–±–∞–Ω–∏—è –≥—Ä–æ–º–∫–æ—Å—Ç–∏",
    "–∫–æ–ª–µ–±–∞–Ω–∏—è –≤—ã—Å–æ—Ç—ã",
    "—É—Å–∏–ª–µ–Ω–∏–µ –±–∞—Å—Å–æ–≤",
    "—É—Å–∏–ª–µ–Ω–∏–µ —Å—Ä–µ–¥–Ω–∏—Ö —á–∞—Å—Ç–æ—Ç",
    "—É—Å–∏–ª–µ–Ω–∏–µ —Å—Ä–µ–¥–Ω–∏—Ö –∏ –≤—ã—Å–æ–∫–∏—Ö —á–∞—Å—Ç–æ—Ç",
    "—ç—Ñ—Ñ–µ–∫—Ç –∫–∞—Å—Å–µ—Ç—ã",
    "–ø–æ–≤—ã—à–µ–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏",
]

options = []

for i in range(len(filters)):
    options.append(
        SelectOption(
            label=list(filters.keys())[i],
            description=descriptions[i],
            emoji="<:ev_shadow_add_primary:1239113713768861877>",
        )
    )


async def check_voice(player, inter: disnake.Interaction, with_message=False):
    await inter.response.defer(ephemeral=True, with_message=with_message)

    if not inter.author.voice:
        raise NoInVoice("–Ω–µ –≤ –≤–æ–π—Å–µ")

    if not player or inter.author.voice.channel != inter.guild.voice_client.channel:
        raise NoInVoiceWithMe("–±–æ—Ç –Ω–µ –≤ –≤–æ–π—Å–µ")

    if (
        player.dj_role
        and player.dj_role not in [role.id for role in inter.author.roles]
        and not inter.permissions.administrator
    ):
        raise commands.MissingPermissions(["setup or manage player"])


# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


class ActionsView(disnake.ui.View):
    """View –º–µ–Ω—é –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–µ–π"""

    def __init__(self, player, *, timeout: float | None = None) -> None:
        super().__init__(timeout=timeout)

        self.player: pomice.Player = player

    # async def on_error(self, error: Exception, item, interaction):
    #     if error is commands.CommandError or error is commands.CommandInvokeError:
    #         e = errors.get(error.__cause__.__class__.__name__, '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞. –ü—Ä–æ—Å—Ç–∏—Ç–µ...')
    #     else:
    #         e = errors.get(error.__class__.__name__, '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞. –ü—Ä–æ—Å—Ç–∏—Ç–µ...')

    #     await interaction.send(
    #         embed=type_embed("error", f"```diff\n- {e}```"),
    #         ephemeral=True,
    #         components=[disnake.ui.Button(style=disnake.ButtonStyle.url, label="report", url="https://discord.gg/ua4kpgzpWJ")]
    #         )

    #     logging.error(f'error in view:')
    #     logging.error(traceback.format_exc())

    @disnake.ui.button(
        emoji="<:bookmark_primary:1242557997624983592>",
        label="–ø–æ—Å—Ç–∞–≤–∏—Ç—å –∑–≤–µ–∑–¥–æ—á–∫—É",
        row=0,
        style=disnake.ButtonStyle.gray,
    )
    @check_player_btn_decorator()
    async def recomendations(self, button, interaction):
        if not self.player.current:
            raise NoCurrent("–Ω–µ—Ç —Ç–µ–∫—É—â–µ–≥–æ —Ç—Ä–µ–∫–∞")

        if not self.player.current.info.isStream:
            track = self.player.current
            interaction.bot.db.stars.add_to_stars(
                interaction.author.id,
                build.track(track.info, track.track_type.value, track.thumbnail),
            )

            await interaction.send(
                embed=interaction.bot.embedding.get(
                    title="üü¢ | –î–æ–±–∞–≤–ª–µ–Ω–æ",
                    description="–ó–≤–µ–∑–¥–æ—á–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ `‚≠ê —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –Ω–∞–±–æ—Ä`",
                    color="accent",
                ),
                # embed=genembed(
                #     title="",
                #     description="–ó–≤–µ–∑–¥–æ—á–∫–∞ –ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∞.\n\n–ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –µ–µ –≤ —Å–≤–æ–µ–º [–ø—Ä–æ—Ñ–∏–ª–µ](https://noirplayer.su/me/stars).",
                # ),
                ephemeral=True,
            )
        else:
            return

    @disnake.ui.button(
        emoji="<:alt_route_primary:1239113857461387264>",
        label="–Ω–∞–π—Ç–∏ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤—ã",
        row=1,
        style=disnake.ButtonStyle.gray,
    )
    @check_player_btn_decorator(with_message=True)
    async def alternative(self, button, interaction):
        if self.player.current and self.player.current.track_type in [
            pomice.TrackType.YOUTUBE,
            pomice.TrackType.SPOTIFY,
        ]:
            tracks = await self.player.get_recommendations(
                track=self.player.current, ctx=self.player.current.ctx
            )

            view = TracksView(songs=tracks, player=self.player)
            return await view.refresh_pages(interaction)

        await interaction.delete_original_message()

    # @disnake.ui.button(emoji="<:chatlefttext:1110271673975984291>", label="–Ω–∞–π—Ç–∏ —Ç–µ–∫—Å—Ç‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä", row=2, style=disnake.ButtonStyle.gray)
    # async def lyric(self, button, interaction):
    #     await check_voice(self.player, interaction)

    #     if self.player.current:
    #         try:
    #             lyric = self.client.get_lyrics(self.client.get_watch_playlist(self.player.current.identifier).get('lyrics', {})).get('lyrics', "–ù–µ—Ç —Ç–µ–∫—Å—Ç–∞ –¥–ª—è —ç—Ç–æ–π –ø–µ—Å–Ω–∏ ¬Ø\_(„ÉÑ)_/¬Ø")
    #         except:
    # return await interaction.send(embed=genembed(title=f"–ù–µ—Ç —Ç–µ–∫—Å—Ç–∞ –ø–µ—Å–Ω–∏ |
    # {self.player.current.title}", description=""), ephemeral=True)

    #         async with interaction.channel.typing():
    #             pag = Paginator(prefix="```yaml\n")

    #             for line in lyric.split("\n"):
    #                pag.add_line(line)

    #             for page in pag.pages:
    # await interaction.send(embed=genembed(title=f"–¢–µ–∫—Å—Ç –ø–µ—Å–Ω–∏ |
    # {self.player.current.title}", description=page), ephemeral=True)

    @disnake.ui.button(
        emoji="<:delete_primary:1239113856027070514>",
        label="—É–¥–∞–ª–∏—Ç—å –∏–∑ –æ—á–µ—Ä–µ–¥–∏",
        row=3,
        style=disnake.ButtonStyle.gray,
    )
    @check_player_btn_decorator()
    async def remove(self, button, interaction):
        if self.player.current:
            try:
                await self.player.queue.remove(self.player.current)
                await self.player.play(self.player.queue.next())
            except BaseException:
                pass

    @disnake.ui.button(
        emoji="<:equalizer_primary:1239113717656977439>",
        label="—ç–∫–≤–∞–ª–∞–π–∑–µ—Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä",
        row=4,
        style=disnake.ButtonStyle.gray,
    )
    @check_player_btn_decorator()
    async def eq(self, button, inter):
        await inter.send(ephemeral=True, view=FiltersView(self.player))


# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


class FiltersView(disnake.ui.View):
    """View —Ñ–∏–ª—å—Ç—Ä—ã"""

    def __init__(self, player, *, timeout: float | None = 600) -> None:
        super().__init__(timeout=timeout)
        self.player = player

        if self.player.disable_eq:  # –ï—Å–ª–∏ —ç–∫–≤–∞–ª–∞–π–∑–µ—Ä –≤—ã–∫–ª—é—á–µ–Ω
            self.eq._underlying.disabled = True

    @disnake.ui.select(placeholder="—Ñ–∏–ª—å—Ç—Ä—ã", options=options, row=0, max_values=7)
    async def eq(self, select: disnake.ui.StringSelect, inter):
        await self.player.reset_filters()

        await inter.response.defer()

        for filter in inter.data.values:
            try:
                await self.player.add_filter(
                    filters[filter],
                )
            except BaseException:
                pass

    @disnake.ui.button(
        emoji="<:ev_shadow_minus_primary:1239113854684893194>",
        label="—Å–±—Ä–æ—Å–∏—Ç—å –≤—Å–µ —Ñ–∏–ª—å—Ç—Ä—ã",
        row=2,
        style=disnake.ButtonStyle.gray,
    )
    async def reset_filters(self, button, inter):
        await self.player.reset_filters()

        await inter.response.defer()

    # async def on_error(self, error: Exception, item, interaction):
    #     pass


# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


class QueueView(disnake.ui.View):
    """View –æ—á–µ—Ä–µ–¥—å"""

    def __init__(self, player, *, timeout: float | None = 180) -> None:
        self.player: pomice.Player = player
        self.index = 0
        self.pag = Paginator(prefix="```yaml\n")

        super().__init__(timeout=timeout)

    # async def on_error(self, error: Exception, item, interaction):
    #     pass

    async def refresh_pages(self, interaction):
        self.pag.clear()

        if self.player.queue.is_empty:
            return await interaction.edit_original_message(
                embed=interaction.bot.embedding.get(
                    {
                        "name": "–∏–≥—Ä–∞–µ—Ç",
                        "value": (
                            self.player.current.info.title
                            if self.player.current
                            else "–ù–∏—á–µ–≥–æ –Ω–µ –∏–≥—Ä–∞–µ—Ç"
                        ),
                    },
                    title="üîµ | –ü—É—Å—Ç–æ",
                    color="info",
                ),
                # embed=genembed(
                #     title=(
                #         f'–û—á–µ—Ä–µ–¥—å –ø—É—Å—Ç–∞ | –°–µ–π—á–∞—Å –∏–≥—Ä–∞–µ—Ç "{self.player.current.info.title}"'
                #         if self.player.current
                #         else "–û—á–µ—Ä–µ–¥—å –ø—É—Å—Ç–∞ | –ù–∏—á–µ–≥–æ –Ω–µ –∏–≥—Ä–∞–µ—Ç"
                #     ),
                #     description="",
                # )
            )

        i = n = 0
        for val in self.player.queue.get_queue():
            if n >= 30:
                self.pag.close_page()
                n = 0

            if i == self.player.queue.find_position(self.player.current):
                ind = ">"
            else:
                ind = ""

            self.pag.add_line(
                f"{i + 1} -{ind} "
                + val.info.title
                + f" [{val.requester.display_name if val.requester else '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'}]"
            )

            i += 1
            n += 1

        total = (
            (
                (
                    sum(
                        i.info.length
                        for i in self.player.queue.get_queue()[
                            self.player.queue.find_position(self.player.current) :
                        ]
                    )
                    - self.player.position
                )
                / 1000
            )
            if not self.player.queue.is_empty
            else 0
        )

        total = int(time.time() + total)

        await interaction.edit_original_message(
            embed=interaction.bot.embedding.get(
                {"name": "–í—Å–µ–≥–æ —Ç—Ä–µ–∫–æ–≤", "value": f"`{self.player.queue.count}`"},
                {"name": "–ó–∞–∫–æ–Ω—á–∏—Ç—Å—è", "value": f"<t:{total}:R>"},
                title="üîµ | –û—á–µ—Ä–µ–¥—å",
                description=self.pag.pages[self.index],
                footer=f"page {self.index + 1}/{len(self.pag.pages)}",
                color="info",
            ),
            # embed=genembed(
            #     title=(
            #         f'–û—á–µ—Ä–µ–¥—å | –°–µ–π—á–∞—Å –∏–≥—Ä–∞–µ—Ç "{self.player.current.info.title}"'
            #         if self.player.current
            #         else "–û—á–µ—Ä–µ–¥—å | –ù–∏—á–µ–≥–æ –Ω–µ –∏–≥—Ä–∞–µ—Ç"
            #     ),
            #     description=self.pag.pages[self.index],
            #     footer=f"page {self.index + 1}/{len(self.pag.pages)}",
            # )
            # .add_field(name="–í—Å–µ–≥–æ —Ç—Ä–µ–∫–æ–≤", value=f"`{self.player.queue.count}`")
            # .add_field(name="–ó–∞–∫–æ–Ω—á–∏—Ç—Å—è", value=f"<t:{total}:R>"),
            # .add_field(
            #     name="–ü–æ—Ç–æ–∫",
            #     value=f"`{'–î–∞' if self.player.queue.is_nonstop else '–ù–µ—Ç'}`",
            # ),
            view=self,
        )

    @disnake.ui.button(
        emoji="<:skip_previous_primary:1239113698623225908>",
        row=0,
        style=disnake.ButtonStyle.gray,
    )
    async def prev(self, button, interaction):
        await interaction.response.defer()
        if self.index > 0:
            self.index -= 1
            return await self.refresh_pages(interaction)

    @disnake.ui.button(
        emoji="<:skip_next_primary:1239113700594679838>",
        row=0,
        style=disnake.ButtonStyle.gray,
    )
    async def next(self, button, interaction):
        await interaction.response.defer()
        if (self.index + 1) < len(self.pag.pages):
            self.index += 1
            return await self.refresh_pages(interaction)

    @disnake.ui.button(
        emoji="<:shuffle_primary:1239115175337001071>",
        row=0,
        style=disnake.ButtonStyle.gray,
    )
    async def shuffle(self, button, interaction):
        await interaction.response.defer()
        await self.player.queue.shuffle()
        await self.refresh_pages(interaction)

    @disnake.ui.button(
        emoji="<:autoplay_primary:1239113693690859564>",
        label="loose mode",
        row=0,
        style=disnake.ButtonStyle.gray,
    )
    async def recomendations(self, button, interaction):
        await interaction.response.defer()
        if not self.player.current:
            return

        self.player.queue.set_nonstop(not self.player.queue.is_nonstop)

        return await self.refresh_pages(interaction)

    @disnake.ui.button(
        emoji="<:save_primary:1239113692306739210>",
        label="—Å–æ—Ö—Ä–∞–Ω–∏—Ç—å",
        row=0,
        style=disnake.ButtonStyle.gray,
    )
    async def shuffle(self, button, interaction):
        tracks = [
            build.track(track.info, track.track_type.value, track.thumbnail)
            for track in self.player.queue.get_queue()
        ]

        from components.ui.modals import PlaylistInfoModal

        await interaction.response.send_modal(
            PlaylistInfoModal(
                node=self.player.node, title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –æ—á–µ—Ä–µ–¥—å", tracks=tracks
            )
        )


# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


class TracksView(disnake.ui.View):
    """View –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ —Ç—Ä–µ–∫–∏"""

    def __init__(
        self, songs, player, *, title="–ü–æ—Ö–æ–∂–∏–µ", timeout: float | None = 180
    ) -> None:
        self.player = player
        self.songs = songs
        self.title = title

        self.index = 0

        super().__init__(timeout=timeout)

    # async def on_error(self, error: Exception, item, interaction):
    #     pass

    async def refresh_pages(self, interaction):
        embed = (
            interaction.bot.embedding.get(
                author_name=self.title,
                title=self.songs[self.index].info.title,
                description=self.songs[self.index].info.author,
                image=self.songs[self.index].info.artworkUrl,
                use_light_color=True,
            ),
        )
        # embed = genembed(
        #     author_name=self.title,
        #     title=self.songs[self.index].info.title,
        #     description=self.songs[self.index].info.author,
        #     image=self.songs[self.index].info.artworkUrl,
        #     footer=f"—Å—Ç—Ä–∞–Ω–∏—Ü–∞ {self.index + 1}/{len(self.songs)}",
        # )

        await interaction.edit_original_message(embed=embed, view=self)

    @disnake.ui.button(
        emoji="<:skip_previous_primary:1239113698623225908>",
        row=0,
        style=disnake.ButtonStyle.gray,
    )
    async def prev(self, button, interaction):
        await interaction.response.defer()
        if self.index > 0:
            self.index -= 1
            return await self.refresh_pages(interaction)

        await interaction.response.defer(ephemeral=True)

    @disnake.ui.button(
        emoji="<:skip_next_primary:1239113700594679838>",
        row=0,
        style=disnake.ButtonStyle.gray,
    )
    async def next(self, button, interaction):
        await interaction.response.defer()
        if (self.index + 1) < len(self.songs):
            self.index += 1
            return await self.refresh_pages(interaction)

        await interaction.response.defer(ephemeral=True)

    @disnake.ui.button(
        label="–î–æ–±–∞–≤–∏—Ç—å –≤ –æ—á–µ—Ä–µ–¥—å", row=0, style=disnake.ButtonStyle.gray
    )
    async def add_to_queue(self, button, interaction):
        if self.player:
            track = (
                await self.player.get_tracks(
                    query=self.songs[self.index].get("url"),
                    ctx=interaction,
                    search_type=pomice.SearchType.ytmsearch,
                )
            )[0]
            await self.player.queue.put(track)
            if not self.player.current:
                await self.player.play(self.player.queue.get())

        await interaction.response.defer(ephemeral=True)


# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


class StarsView(disnake.ui.View):
    """View  –∑–≤–µ–∑–¥–æ—á–∫–∏"""

    def __init__(
        self, songs, player, *, title="–ò–∑–±—Ä–∞–Ω–Ω–æ–µ", timeout: float | None = 600
    ) -> None:
        self.player = player
        self.songs = songs
        self.title = title

        self.index = 0

        super().__init__(timeout=timeout)

    # async def on_error(self, error: Exception, item, interaction):
    #     pass

    async def refresh_pages(self, interaction):
        embed = (
            interaction.bot.embedding.get(
                author_name=self.title,
                title=self.songs[self.index].get("title", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ"),
                description=self.songs[self.index].get("author", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∞–≤—Ç–æ—Ä"),
                image=self.songs[self.index].get("thumbnail"),
                footer=f"song {self.index + 1}/{len(self.songs)}",
            )
            if len(self.songs)
            else interaction.bot.embedding.get(
                title="üü† | –ü—É—Å—Ç–æ",
                description="–£ –≤–∞—Å –Ω–µ—Ç –∏–∑–±—Ä–∞–Ω–Ω—ã—Ö —Ç—Ä–µ–∫–æ–≤",
                color="warning",
            )
            # else genembed(title="", description="–£ –≤–∞—Å –Ω–µ—Ç –∏–∑–±—Ä–∞–Ω–Ω—ã—Ö —Ç—Ä–µ–∫–æ–≤.")
        )

        await interaction.edit_original_message(embed=embed, view=self)

    @disnake.ui.button(
        emoji="<:skip_previous_primary:1239113698623225908>",
        row=0,
        style=disnake.ButtonStyle.gray,
    )
    async def prev(self, button, interaction):
        await interaction.response.defer()
        if self.index > 0:
            self.index -= 1
            return await self.refresh_pages(interaction)

        await interaction.response.defer(ephemeral=True)

    @disnake.ui.button(
        emoji="<:skip_next_primary:1239113700594679838>",
        row=0,
        style=disnake.ButtonStyle.gray,
    )
    async def next(self, button, interaction):
        await interaction.response.defer()
        if (self.index + 1) < len(self.songs):
            self.index += 1
            return await self.refresh_pages(interaction)

        await interaction.response.defer(ephemeral=True)

    @disnake.ui.button(
        label="–î–æ–±–∞–≤–∏—Ç—å –≤ –æ—á–µ—Ä–µ–¥—å", row=0, style=disnake.ButtonStyle.gray
    )
    async def add_to_queue(self, button, interaction):
        if self.player:
            track = (
                await self.player.get_tracks(
                    query=self.songs[self.index].get("url"), ctx=interaction
                )
            )[0]
            await self.player.queue.put(track)
            if not self.player.current:
                await self.player.play(self.player.queue.get())

        await interaction.response.defer(ephemeral=True)

    @disnake.ui.button(label="–°–Ω—è—Ç—å –∑–≤–µ–∑–¥–æ—á–∫—É", row=1, style=disnake.ButtonStyle.gray)
    async def unstar(self, button, interaction):
        await interaction.response.defer()
        interaction.bot.db.stars.remove_from_stars(
            self.songs[self.index].get("url"), interaction.author.id
        )
        self.songs = interaction.bot.db.stars.get_stars(interaction.author.id).get(
            "tracks"
        )

        if self.index + 1 >= len(self.songs):
            self.index -= 1

        return await self.refresh_pages(interaction)


# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


class PlaylistView(disnake.ui.View):
    """View  –ø–ª–µ–π–ª–∏—Å—Ç–∞"""

    def __init__(
        self, info: dict, node, edit=True, *, timeout: float | None = None
    ) -> None:
        self.node = node
        self.uuid = info.get("uuid")

        self.info: dict = info
        self.songs: list = info.get("tracks")

        self.index = 0

        super().__init__(timeout=timeout)

        if (
            not pomice.enums.URLRegex.BASE_URL.search(info.get("thumbnail", ""))
            or requests.head(info.get("thumbnail")).status_code != requests.codes.ok
        ):  # –ï—Å–ª–∏ —ç—Ç–æ –Ω–µ —Å—Å—ã–ª–∫–∞ –∏–ª–∏ —Å—Å—ã–ª–∫–∞ –Ω–µ–≤–∞–ª–∏–¥–Ω–∞—è
            # –ó–∞–º–µ–Ω—è–µ–º –æ–±–ª–æ–∂–∫—É, –µ—Å–ª–∏ –µ–µ –Ω–µ—Ç
            info["thumbnail"] = (
                "https://cataas.com/cat/says/–û–±–ª–æ–∂–∫–∞%20–Ω–µ%20–Ω–∞–π–¥–µ–Ω–∞?type=square&width=500"
            )

        if not edit:  # –ï—Å–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ –∏–∑–º–µ–Ω–µ–Ω–∏–µ –ø–ª–µ–π–ª–∏—Å—Ç–∞
            self.remove_item(self.add_to_playlist)
            self.remove_item(self.delete_from_playlist)

        # if not table("playlists").find_one({"uuid": self.info.get('forked')}): # –ï—Å–ª–∏ –ø–ª–µ–π–ª–∏—Å—Ç –Ω–µ —Å–∏—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º—ã–π
        #     self.remove_item(self.sync_from_playlist)

        self.add_item(
            disnake.ui.Button(
                label="—Å—Å—ã–ª–∫–∞ –Ω–∞ –ø–ª–µ–π–ª–∏—Å—Ç",
                url=f"https://noirplayer.su/playlists/{self.uuid}",
                row=1,
            )
        )

    # async def on_error(self, error: Exception, item, interaction):
    #     pass

    async def refresh_pages(self, interaction):
        if not self.index:
            self.songs = interaction.bot.db.playlists.get_playlist(self.uuid)
            embed = (
                interaction.bot.embedding.get(
                    {
                        "name": "`–∞–≤—Ç–æ—Ä`",
                        "value": f"`{self.info.get('author', {}).get('name')}`",
                    },
                    {
                        "name": "`—Ç—Ä–µ–∫–∏`",
                        "value": f"{f'`{len(self.songs)}`' if self.songs else '‚≠ê –¥–æ–±–∞–≤—å—Ç–µ —Å –ø–æ–º–æ—â—å—é <:pluscircle:1118459100150378550>'}",
                    },
                    title=self.info.get("title"),
                    description=self.info.get("description", "")
                    + "\n\n–°–≤–∞–π–ø–Ω–∏—Ç–µ –Ω–∞ <:skip_next_primary:1239113700594679838>, —á—Ç–æ–±—ã –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ç—Ä–µ–∫–∏",
                    image=self.info.get("thumbnail"),
                    footer=f"{'–ø—É–±–ª–∏—á–Ω—ã–π –ø–ª–µ–π–ª–∏—Å—Ç' if self.info.get('public') else '–ø—Ä–∏–≤–∞—Ç–Ω—ã–π –ø–ª–µ–π–ª–∏—Å—Ç'}",
                ),
            )
            # embed = genembed(
            #     title=self.info.get("title"),
            #     description=self.info.get("description", "")
            #     + "\n\n–°–≤–∞–π–ø–Ω–∏—Ç–µ –Ω–∞ <:skip_next_primary:1239113700594679838>, —á—Ç–æ–±—ã –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ç—Ä–µ–∫–∏",
            #     image=self.info.get("thumbnail"),
            #     author_name=None,
            #     footer=f"{'–ø—É–±–ª–∏—á–Ω—ã–π –ø–ª–µ–π–ª–∏—Å—Ç' if self.info.get('public') else '–ø—Ä–∏–≤–∞—Ç–Ω—ã–π –ø–ª–µ–π–ª–∏—Å—Ç'} | {', '.join(self.info.get('tags', []) if self.info.get('tags') else [])}",
            # )
            # embed.add_field("–ê–≤—Ç–æ—Ä", f"`{self.info.get('author', {}).get('name')}`")
            # embed.add_field(
            #     "–¢—Ä–µ–∫–∏",
            #     f"{f'`{len(self.songs)}`' if self.songs else '–î–æ–±–∞–≤—å—Ç–µ —Å –ø–æ–º–æ—â—å—é <:pluscircle:1118459100150378550>'}",
            # )

        else:
            embed = (
                interaction.bot.embedding.get(
                    author_name=f'–ü–ª–µ–π–ª–∏—Å—Ç | {self.info.get("title")}',
                    author_icon=self.info.get(
                        "thumbnail", "https://noirplayer.su/static/image/nocover.png"
                    ),
                    title=self.songs[self.index - 1].get("title"),
                    description=self.songs[self.index - 1].get("author"),
                    image=self.songs[self.index - 1].get("thumbnail"),
                    footer=f"page {self.index} / {len(self.songs)}",
                ),
            )
            # embed = genembed(
            #     author_name=f'–ü–ª–µ–π–ª–∏—Å—Ç | {self.info.get("title")}',
            #     author_icon=self.info.get(
            #         "thumbnail", "https://noirplayer.su/static/image/nocover.png"
            #     ),
            #     title=self.songs[self.index - 1].get("title"),
            #     description=self.songs[self.index - 1].get("author"),
            #     image=self.songs[self.index - 1].get("thumbnail"),
            #     footer=f"page {self.index}/{len(self.songs)}",
            # )
        try:
            await interaction.edit_original_message(embed=embed, view=self)
        except disnake.HTTPException:
            embed.set_image("https://noirplayer.su/static/image/nocover.png")
            await interaction.edit_original_message(embed=embed, view=self)

    @disnake.ui.button(
        emoji="<:skip_previous_primary:1239113698623225908>",
        row=0,
        style=disnake.ButtonStyle.gray,
    )
    async def prev(self, button, interaction):
        await interaction.response.defer()
        self.songs = interaction.bot.db.playlists.get_playlist(self.uuid).get("tracks")
        if self.index > 0:
            self.index -= 1
            return await self.refresh_pages(interaction)

    @disnake.ui.button(
        emoji="<:skip_next_primary:1239113700594679838>",
        row=0,
        style=disnake.ButtonStyle.gray,
    )
    async def next(self, button, interaction):
        await interaction.response.defer()
        self.songs = interaction.bot.db.playlists.get_playlist(self.uuid).get("tracks")
        if (self.index) < (len(self.songs) if self.songs else 0):
            self.index += 1
            return await self.refresh_pages(interaction)

    @disnake.ui.button(
        emoji="<:delete_primary:1239113856027070514>",
        row=0,
        style=disnake.ButtonStyle.gray,
    )
    async def delete_from_playlist(self, button, interaction):
        await interaction.response.defer()

        if self.index:
            interaction.bot.db.playlists.remove_from_playlist(
                self.uuid, interaction.author.id, self.songs[self.index - 1].get("url")
            )
            del self.songs[self.index - 1]
            if self.index >= len(self.songs):
                self.index -= 1
            return await self.refresh_pages(interaction)
        else:
            return

    @disnake.ui.button(
        emoji="<:playlist_add_primary:1239115838557126678>",
        row=0,
        style=disnake.ButtonStyle.gray,
    )
    async def add_to_playlist(self, button, interaction):
        from components.ui.modals import AddToPlaylist

        await interaction.response.send_modal(AddToPlaylist(self.node, self, self.uuid))
        await interaction.delete_original_message()
